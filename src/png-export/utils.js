const { getTargetPointsOnModule, findClosestPointPair } = require("./helper");

/**
 * Generates a random number between given minimum and maximum number.
 * @param {Number} min Minimum number to include in returned value
 * @param {Number} max Maximum number to include in returned value
 */
const random = 
    (min, max) => Math.floor(Math.random() * (max - min) + min);

/**
 * Generates a random color with rgb values from 0-100 each
 */
const randomColorRGB = 
    () => { return {r: random(0, 100), g: random(0, 100), b: random(0, 100)} };

/**
 * Generates a rgb color string from the given color object
 * @param {Object} color object containing rgb values
 */
const parseColor =
    (color) => `rgb(${color.r},${color.g},${color.b})`;

/**
 * Returns a inverted color object based on given color object
 * @param {Object} color color object containing rbg values
 */
const invertColor = 
    (color) => { return {r: 255 - color.r, g: 255 - color.g, b: 255 - color.b} };

/**
 * Draws a arrow line from given starting to ending positions
 * @param {CanvasRenderingContext2D} context context of canvas object
 * @param {Number} fromx X coordinate of line start
 * @param {Number} fromy Y coordinate of line start
 * @param {Number} tox X coordinate of line end
 * @param {Number} toy Y coordinate of line end
 */
const drawArrow = (context, fromx, fromy, tox, toy) => {
    var headlen = 15;   // length of head in pixels
    var angle = Math.atan2(toy-fromy,tox-fromx);
    drawLine(context, fromx, fromy, tox, toy);

    context.lineWidth = 1;
    context.moveTo(tox, toy);
    context.lineTo(tox-headlen*Math.cos(angle-Math.PI/6),toy-headlen*Math.sin(angle-Math.PI/6));
    context.lineTo(tox-headlen*Math.cos(angle+Math.PI/6),toy-headlen*Math.sin(angle+Math.PI/6));

    context.fill();
};

/**
 * Draws a line from given starting to ending positions
 * @param {CanvasRenderingContext2D} context context of canvas object
 * @param {Number} fromx X coordinate of line start
 * @param {Number} fromy Y coordinate of line start
 * @param {Number} tox X coordinate of line end
 * @param {Number} toy Y coordinate of line end
 */
const drawLine = (context, fromx, fromy, tox, toy) => {
    context.moveTo(fromx, fromy);
    context.lineTo(tox, toy);
    context.stroke();
};

/**
 * Maps a color to export type
 * @param {String} type type of exported object
 */
const getBgColorFromExportType = (type) => {
    switch(type) {
        case "function": return "#c0392b";
        case "object": return "#2c3e50";
        case "number":  return "#8e44ad";
        case "boolean": return "#2980b9";
        case "string": return "#27ae60";
        default: return "#f39c12";
    }
};

/**
 * Draw a vertice between given two modules.
 * @param {CanvasRenderingContext2D} context 2D context of canvas object
 * @param {Object} mod1 dimensions of starting module
 * @param {Object} mod2 dimensions of ending module
 */
const drawVertice = (context, mod1, mod2) => {
    if(!mod1 || !mod2) return;
    context.save();
    
    /** Retrieve the two points which results in smallest line */
    const selectedPoints = findClosestPointPair(
        getTargetPointsOnModule(mod1),
        getTargetPointsOnModule(mod2)
    );
    
    /** Draw the line */
    context.beginPath();
    context.lineWidth = 5;
    context.strokeStyle = mod1.color;
    context.fillStyle = mod1.color;
    
    drawLine(context, selectedPoints.start.x, selectedPoints.start.y, selectedPoints.end.x, selectedPoints.end.y);
    
    /** draw a circle on mod2 where line intersects */
    context.beginPath();
    context.lineWidth = 1;
    context.fillStyle = "#3498db";
    context.arc(selectedPoints.end.x, selectedPoints.end.y, 6, 0, Math.PI*2);
    context.fill();
    
    context.restore();
};

/**
 * Draw a module on the canvas.
 * @param {CanvasRenderingContext2D} context 2D context of canvas object
 * @param {Object} size Dimension of target module
 * @param {Graph} module Module object generated by coorsponding generator
 */
const drawModule = (context, size, module) => {
    context.save();

    context.fillStyle = size.color;
    context.shadowBlur = 5;
    context.shadowColor = size.color;

    /** If this is a module, draw a recctangle */
    if(!size.isCircle)
        context.fillRect(size.x, size.y, size.width, size.height);
    else {
        /** otherwise draw a circle */
        context.arc(size.x + size.width/2, size.y + size.height/2, Math.max(size.width, size.height), 0, 2*Math.PI);
        context.fill();
        context.beginPath();
    }
    
    context.fillStyle = size.textColor;
    context.font = '30px Impact';
    context.fillText(module._name, size.x + 10, size.y + 10 + 30);

    const keys = Object.keys(module._exports);

    /** Show exports */
    for(let i = 0; i < keys.length; i++) {
        context.font = '20px Impact';
        context.fillStyle = size.textColor;
        context.fillText(keys[i], size.x + 10, size.y + 10 + 20*(i+3) + 5);

        /** show typeof export */
        context.font = '10px Impact';
        const type = module._exports[keys[i]];
        const valueSize = context.measureText(type);

        const startingX = size.x  + size.width - 10 - valueSize.width;
        const startingY = size.y + 10 + 20*(i+3) + 5;

        /** draw rectangle around type */
        context.fillStyle = getBgColorFromExportType(type);
        context.fillRect(startingX - 10, startingY - 20, valueSize.width + 20, 20);

        context.fillStyle = "#ecf0f1";
        context.fillText(type, startingX, startingY - 5);
    }
    
    context.restore();
};

/**
 * Generates a dimension object for target module.
 * It defines x, y, width, height, bgColor, textColor of the target module for drawing on canvas.
 * @param {CanvasRenderingContext2D} context 2D context of canvas object
 * @param {Object} module Module object containing import/exports and name of module
 * @param {Number} level Current level of module
 * @param {Number} posInArray Module position in array
 * @param {Number} numModules Total number of modules
 * @param {Number} width Width of canvas
 * @param {Number} height Height of canvas
 * @param {Number} numLevels Total number of levels
 */
const allocateModule = (context, module, level, posInArray, numModules, width, height, numLevels) => {
    context.font = '30px Impact';
    const size = context.measureText(module._name);
    const gapFromTop = (level-1) * (height / numLevels) + (level == 1 ? 100: 0);
    const moduleWidth = (width / numModules);
    const gapFromLeft = moduleWidth * posInArray + (moduleWidth/2 - size.width/2);
    const color = randomColorRGB();
    const textColor = {r: 200, g: 200, b: 200};//invertColor(color);

    // 20 (font size) * number of lines of exports + 30 * name of module + 10 padding between exports and name + padding
    const heightOfModule = 25 * (Object.keys(module._exports).length) + 30 + 10 + 20;

    // width of maximum export or name with typeof export with gap of 20 inbetween and padding of 20
    context.font = '20px Impact';
    const widthOfModule = 20 + Object.keys(module._exports)
                                .map(a => context.measureText(a).width + 20 + context.measureText(module._exports[a]).width)
                                .filter(a => a !== undefined && a !== null )
                                .reduce((acc, a) => Math.max(acc, a), size.width);

    return {
        x: gapFromLeft,
        y: gapFromTop,
        width: widthOfModule,
        height: heightOfModule,
        color: parseColor(color),
        textColor: parseColor(textColor),
        isCircle: module.Exports.length === 0
    };
};

/**
 * Draw a watermark text on the bottom right of canvas
 * @param {CanvasRenderingContext2D} context 2D context of canvas object
 * @param {Number} width Width of canvas
 * @param {Number} height Height of canvas
 * @param {String} text text to show as watermark
 */
const drawWaterMark = (context, width, height, text) => {
    context.save();
    
    context.font = "bold 30px Impact";
    const size = context.measureText(text);

    // Add margin of 20px to right 
    const startPosition = width - size.width - 20;

    /** Draw a dark background banner for watermark */
    context.fillStyle = "#FF5722";
    context.fillRect(0, height - 50, width, height);

    /** Write text */
    context.fillStyle = "#B3E5FC";
    context.fillText(text, startPosition,  height - 15);
    context.restore();
};

/**
 * Add background color to the convas
 * @param {CanvasRenderingContext2D} context 2D context of canvas object
 * @param {Number} width Width of canvas
 * @param {Number} height Height of canvas
 * @param {String} color color of background
 */
const drawBackground = (context, width, height, color) => {
    context.save();

    context.fillStyle = color;
    context.fillRect(0, 0, width, height);

    context.restore();
};

module.exports = {
    drawVertice,
    drawModule,
    allocateModule,
    drawWaterMark,
    drawBackground
};